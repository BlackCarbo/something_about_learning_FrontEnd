1.说一下进程和线程的区别？协程呢？
--进程是一个程序在一个数据集中的一次动态执行过程，可以简单理解为“正在执行的程序”，它是CPU资源分配和调度的独立单位。进程一般由程序、数据集、进程控制块三部分组成。
--线程是在进程之后发展出来的概念。线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。一个进程可以包含多个线程。 
--协程是一种用户态的轻量级线程，又称微线程，英文名Coroutine，协程的调度完全由用户控制。人们通常将协程和子程序（函数）比较着理解。 
--协程的执行效率非常高。协程不需要多线程的锁机制。
--进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
--线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
--协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。


2.进程间通信的方式——信号、管道、消息队列、共享内存
--管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
--命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
--消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
--共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
--信号(sinal): 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
--套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



3.线程同步的方式包括：互斥锁、读写锁、条件变量、信号量和令牌。
--互斥锁和读写锁：提供对临界资源的保护，当多线程试图访问临界资源时，都必须通过获取锁的方式来访问临界资源。（临界资源：是被多线程共享的资源）当读写线程获取锁的频率差别不大时，一般采用互斥锁，如果读线程访问临界资源的频率大于写线程，这个时候采用读写锁较为合适，读写锁允许多个读线程同时访问临界资源，读写线程必须互斥访问临界资源。读写锁的实现采用了互斥锁，所以在读写次数差不多的情况下采用读写锁性能没有直接采用互斥锁来的高。
--条件变量：提供线程之间的一种通知机制，当某一条件满足时，线程A可以通知阻塞在条件变量上的线程B，B所期望的条件已经满足，可以解除在条件变量上的阻塞操作，继续做其他事情。
--信号量：提供对临界资源的安全分配。如果存在多份临界资源，在多个线程争抢临界资源的情况下，向线程提供安全分配临界资源的方法。如果临界资源的数量为1，将退化为锁。
--令牌：一种高级的线程同步的方法。它既提供锁的安全访问临界资源的功能，又利用了条件变量使得线程争夺临界资源时是有序的。

4.什么是死锁,死锁产生条件以及预防办法
产生死锁的原因主要是：
　　（1） 因为系统资源不足。
　　（2） 进程运行推进的顺序不合适。
　　（3） 资源分配不当等。
　　如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则
　　就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。
　　产生死锁的四个必要条件：
　　（1） 互斥条件：一个资源每次只能被一个进程使用。
　　（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
　　（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
　　（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
　　一不满足，就不会发生死锁。
死锁的解除与预防：
　　理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和
　　解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确
　　定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态
　　的情况下占用资源。因此，对资源的分配要给予合理的规划。

5.数据库如何应对大规模写入和读取?
--可以利用foreach循环插入数据.
--你可以批量插入数据库
--可以考虑做一个缓存，将要写入的数据先写到缓存里面，当缓存达到一定的阈值再一次性写入Mysql，这样避免了小数据量的频繁写入和读取，对mysql的性能能起到很大的提升。

6.什么是读写分离，如何实现负载均衡?
--读写分离，主要是把数据库的读操作与写操作给分开，我们进行MySQL主从复制配置的一个主要目的就是分担数据库的读负载这是因为对于大多数的应用来说数据。写负载是不能够分担的而且还只能在主上进行写操作，读操作既可以在主上进行也可以在从上进行，所以为了减少主库由于读操作所带来的这个压力而让主库更专注的进行写操作所以我们希望把读操作与写操作进行分开。写操作只能在主库上进行，而读操作尽量的在从上进行，这样我们就需要对操作进行区分也就是说要进行读写分离，而完成读写分离后对于读操作可以在多个从上进行处理，而如何分配多个服务器的读操作呢？这就需要读的负载均衡了。
--读写分离主要有两种方式，1：是由程序实现读写分离。2，由中间件来实现读写分离。


7.HashMap的工作原理：
--HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。HashMap在每个LinkedList节点中储存键值对对象。
--当两个不同的键对象的hashcode相同时会发生什么？它们会储存在同一个bucket位置的LinkedList中。键对象的equals()方法用来找到键值对。


8.大数据本质是什么，基础理论应该怎么理解？
--大数据是一个体量特别大、数据类别特别多的数据集，并且这样的数据集无法用传统软件工具对其内容进行抓取、管理和处理。
一，大数据的“大”。与传统数据的储存方式相比是几何量级的差距。
二，多维度。表示大数据可以对一个事物进行多方位的描述，从而更准确。
三，处理非结构数据的能力。未来10年新生数据总量的90%为非结构化数据。大数据通过图像识别，语音识别，自然语言分析等技术计算，分析大量非结构化数据，大大提升数据维度。
四，大数据是生生不息的“流”，具有时间性。一是因为数据量巨大，无法全部储存。另一方面是大数据和人类生生不息的行动相关，瞬息万变。
五，最重要的是，大数据的大表现为无尽的重复。量变促成质变，在机器智能领域，数据量的大小和处理速度的快慢可以直接决定智力水平的高低。

9.什么是Hadoop？Spark？
--Hadoop是一个能够对大量数据进行分布式处理的软件框架。
--Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。

10.流式大数据处理的三种框架：Storm，Spark和Samza

11.数据库为什么用B+树？
--B-tree利用了磁盘块的特性进行构建的树。每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。B+tree 是 B-tree 的变种，B+tree数据只存储在叶子节点中。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;

12.二叉树序列化与反序列化
--把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。
--根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

13.TCP三次握手，四次挥手
--服务器进程进入监听状态；客户进程向服务器发出连接请求报文；服务器收到请求报文后，如果同意连接，则发出确认报文；客户进程收到确认后，还要向服务器给出确认。服务器收到客户端的确认后双方就可以开始通信。
--客户端进程发出连接释放报文，并且停止发送数据；服务器收到连接释放报文，发出确认报文；客户端收到服务器的确认请求后等待服务器发送连接释放报文；服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，等待客户端的确认；客户端收到服务器的连接释放报文后，必须发出确认；服务器只要收到了客户端发出的确认，立即进入CLOSED状态。

14.创建线程的三种方式
--继承Thread：
	定义一个类MyThread继承Thread，并重写run方法。
	将要执行的代码写在run方法中。
	创建该类的实例，并调用start()方法开启线程。

--实现Runnable接口：
	定义一个类MyRunnable实现Runnable接口，并重写run方法。
	将要执行的代码写在run方法中。
	创建Thread对象，传入MyRunnable的实例，并调用start()方法开启线程。
	
--实现 Callable 接口：
	自定义一个类 MyCallable 实现 Callable 接口，并重写call()方法
	将要执行的代码写在call()方法中
	创建线程池对象，调用submit()方法执行MyCallable任务，并返回Future对象
	调用Future对象的get()方法获取call()方法执行完后的值
	
15.线程池：
--基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
--线程池的优点：
	1）避免线程的创建和销毁带来的性能开销。
	2）避免大量的线程间因互相抢占系统资源导致的阻塞现象。
	3｝能够对线程进行简单的管理并提供定时执行、间隔执行等功能。


16.Linux最常用的20条命令
--cd命令。用于切换当前目录。
--ls命令。查看文件与目录。-a ：列出全部的文件；-l ：列出长数据串
--grep命令。用于分析一行的信息。
--find命令。查找。-name filename ；-tpye TYPE 
--cp命令。用于复制文件。-a ：将文件的特性一起复制 
--mv命令。用于移动文件、目录或更名。-i ：若目标文件已经存在，就会询问是否覆盖
--rm命令。用于删除文件或目录。-i ：互动模式，在删除前会询问用户是否操作 
-- ps命令。用于将某个时间点的进程运行情况选取下来并输出。-A ：所有的进程均显示出来
--kill命令。用于向某个工作或者是某个PID传送一个信号。
--file命令。用于判断接在file命令后的文件的基本数据。
--tar命令。用于对文件进行打包。-c ：新建打包文件；-t ：查看打包文件的内容含有哪些文件名  
--cat命令。查看文本文件的内容，后接要查看的文件名。
--chgrp命令。用于改变文件所属用户组。
--chown命令。用于改变文件的所有者。
--chmod命令。用于改变文件的权限。
--vim命令。用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开。
--gcc命令。用于把C语言的源程序文件，编译成可执行程序。
--time命令。用于测算一个命令（即程序）的执行时间。



多态主要以两种形式，静态多态和动态多态，静态多态主要实现了函数重载和运算符重载。动态多态主要实现了虚函数。虚函数是动态联编，程序在运行的过程中确定调用哪一个函数。








